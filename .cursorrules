# Cursor Rules for Perplexity MCP Server

## OpenSpec MODIFIED Requirements - Strict Matching Rule

When creating MODIFIED requirements in OpenSpec change proposals:

**CRITICAL STEPS (must follow in order):**
1. **Read original spec first**: ALWAYS use `read_file` or `grep` to get the exact current requirement from `openspec/specs/<capability>/spec.md`
2. **Copy complete requirement block**: Copy from `### Requirement: [Name]` through ALL scenarios (including the last one)
3. **Verify header match**: Ensure the requirement header matches EXACTLY (whitespace is normalized, but text must be identical)
4. **Preserve all original scenarios**: Keep every original `#### Scenario:` block
5. **Add new scenarios**: Append new scenarios at the end, marked with `(new)` comment for clarity
6. **Validate before committing**: Run `openspec validate <change-id> --strict`

**Example Workflow:**
```bash
# Step 1: Read the original requirement
grep -A 50 "### Requirement: Conversation Retrieval" openspec/specs/conversation-history/spec.md

# Step 2: Copy ENTIRE block including all scenarios

# Step 3: In change proposal, paste under ## MODIFIED Requirements

# Step 4: Make your changes (add new scenarios, update behavior)

# Step 5: Validate
openspec validate <change-id> --strict
```

**Common Mistake to AVOID:**
❌ Copying only part of the requirement
❌ Forgetting original scenarios
❌ Changing the requirement header text
❌ Using a different header format

**What Happens if Wrong:**
- Archiving will fail to match requirements
- Original scenarios get lost
- Specs become incomplete

**Validation Check:**
Before considering a MODIFIED requirement complete, verify:
- [ ] Original spec file was read
- [ ] Header text matches exactly (check with grep)
- [ ] All original scenarios are present
- [ ] New scenarios are clearly marked
- [ ] `openspec validate --strict` passes

## OpenSpec Archival Workflow - Merging to Ground State

After implementation and testing are complete, archive the change proposal to merge it with the ground state specs.

**CRITICAL STEPS:**
1. **Ensure all work is complete**: All tasks in `tasks.md` should be done and tested
2. **Run archive command**: `openspec archive <change-id> --yes`
3. **Verify merge**: Check that specs updated correctly in the command output
4. **Validate ground state**: Run `openspec validate --specs` to ensure no errors
5. **Commit the archival**: Commit both the archived change and updated ground state specs

**Archive Command:**
```bash
# Archive with automatic confirmation (non-interactive)
openspec archive <change-id> --yes

# Example
openspec archive add-batch-conversation-retrieval --yes
```

**What Happens During Archive:**
- Change directory moves from `openspec/changes/<change-id>/` to `openspec/changes/archive/YYYY-MM-DD-<change-id>/`
- ADDED requirements are appended to corresponding specs in `openspec/specs/<capability>/spec.md`
- MODIFIED requirements replace existing requirements (matched by header)
- REMOVED requirements are deleted from specs
- The archive preserves the original proposal, tasks, and spec deltas for historical reference

**Post-Archive Validation:**
```bash
# Validate all specs in strict mode
openspec validate --specs

# Should show all specs passing, e.g.:
# ✓ spec/async-deep-research
# ✓ spec/conversation-history
# ... (all specs)
```

**Common Issues:**
- **Warning about incomplete tasks**: The `--yes` flag bypasses this check. Ensure tasks are actually complete before archiving.
- **Merge conflicts**: If MODIFIED requirement header doesn't match exactly, archiving may fail or create duplicate requirements.
- **Validation errors after archive**: Usually indicates malformed scenarios or requirements. Check the updated spec files.

**Commit Message Template:**
```
Archive <change-id> proposal and merge to ground state specs

- Archive <change-id> to YYYY-MM-DD-<change-id>
- Update <capability> spec with <new/modified> requirements
- All specs validated successfully with strict mode
```

## Project-Specific Best Practices

### Async/Await Patterns
- Always use `async/await`, never callbacks
- All async functions must handle errors with try/catch
- Use `Promise.all()` for parallel operations only when operations are independent

### File Operations
- Use `renameSync()` for atomic file updates (prevents race conditions)
- Always write to temp file first, then rename
- Never update critical files (status.json, job.json) without atomic rename

### Error Handling
- Wrap external API errors in `McpError`
- Include request context (requestId, conversationId) in all error logs
- Use appropriate error codes: ValidationError, ApiError, NotFoundError, TimeoutError, InternalError

### Type Safety
- No `any` types without strict justification and comment explaining why
- All Zod schemas must be validated before use
- Export types alongside schemas: `export type X = z.infer<typeof XSchema>`

### Testing Requirements
- Write unit tests for all new logic in `tests/unit/`
- Mock external dependencies with `jest.mock()` or `nock`
- All tests must be isolated and not depend on execution order
- Aim for >80% coverage on critical paths

